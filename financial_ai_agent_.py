# -*- coding: utf-8 -*-
"""Financial_AI_Agent_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yb08E-3NkoyYudrLNIFT2jry4gWgqg65
"""

# ‚úÖ 1. INSTALL DEPENDENCIES
!pip install -U langchain langchain-community openai-whisper vosk sentence-transformers faiss-cpu chromadb flask-ngrok fpdf2
!sudo apt update && sudo apt install ffmpeg -y

import os
#Create necessary directories
folders = [
    "modules",
    "modules/finance_apis",
    "data/uploaded_files",
    "data/vector_store/faiss_index",  # FAISS will save here
    "logs",
    "pdf_reports",
    "audio_samples"  # in case you want voice interaction
]
for folder in folders:
    os.makedirs(folder, exist_ok=True)
# Set environment variables (for things like API keys)
os.environ["ALPHA_VANTAGE_API_KEY"] = "LU1ZRAF1HR2V83BK"

# ‚úÖ 3. DATABASE SETUP
import sqlite3
conn = sqlite3.connect("logs/activity_log.db")
cursor = conn.cursor()
cursor.execute('''CREATE TABLE IF NOT EXISTS logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT,
    intent TEXT,
    input_text TEXT,
    response TEXT,
    metadata TEXT
)''')
conn.commit()
conn.close()

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 4. MODULE: speech_to_text.py
# %%writefile modules/speech_to_text.py
# import whisper
# model = whisper.load_model("base")
# def transcribe_audio(audio_path):
#     result = model.transcribe(audio_path)
#     return result['text']

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 5. MODULE: intent_recognizer.py
# %%writefile modules/intent_recognizer.py
# from sentence_transformers import SentenceTransformer, util
# import re
# model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
# 
# intent_map = {
#     "check account balance": "get_account_balance",
#     "generate tax report": "generate_tax_report",
#     "upload and process invoice": "upload_invoice",
#     "fetch cashflow summary": "get_cashflow_summary"
# }
# keyword_map = {
#     "balance": "get_account_balance",
#     "tax": "generate_tax_report",
#     "invoice": "upload_invoice",
#     "cashflow": "get_cashflow_summary",
#     "cash flow": "get_cashflow_summary"
# }
# def get_intent(user_query):
#     queries = list(intent_map.keys())
#     embeddings = model.encode(queries + [user_query], convert_to_tensor=True)
#     similarity = util.pytorch_cos_sim(embeddings[-1], embeddings[:-1])
#     best_idx = similarity.argmax()
#     best_score = similarity[0][best_idx].item()
#     if best_score >= 0.5:
#         return intent_map[queries[best_idx]]
#     lowered = user_query.lower()
#     for keyword, intent in keyword_map.items():
#         if re.search(rf"\\b{keyword}\\b", lowered):
#             return intent
#     return "unknown_intent"

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ modules/file_parser.py
# %%writefile modules/file_parser.py
# import pandas as pd
# import sqlite3
# import os
# from datetime import datetime
# import re
# 
# def sanitize_column_name(name):
#     """Remove special characters and convert to snake_case."""
#     return re.sub(r'\W+', '_', str(name).strip().lower())
# 
# def parse_and_store(file_path):
#     if not os.path.exists(file_path):
#         raise FileNotFoundError(f"File not found: {file_path}")
# 
#     # Read Excel file and get first row as header
#     df = pd.read_excel(file_path)
# 
#     # Sanitize column names to be SQLite-compatible
#     original_columns = df.columns
#     sanitized_columns = [sanitize_column_name(col) for col in original_columns]
#     df.columns = sanitized_columns
# 
#     # Create dynamic table name
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     table_name = f"financial_data_{timestamp}"
# 
#     # Create SQLite connection
#     conn = sqlite3.connect("data/financial_data.db")
#     cursor = conn.cursor()
# 
#     # Generate CREATE TABLE statement dynamically
#     create_table_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}` (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,"
#     for col in sanitized_columns:
#         create_table_sql += f"\n  `{col}` TEXT,"
#     create_table_sql = create_table_sql.rstrip(',') + "\n);"
# 
#     cursor.execute(create_table_sql)
# 
#     # Insert all rows into the table
#     df.to_sql(table_name, conn, if_exists='append', index=False)
# 
#     conn.commit()
#     conn.close()
# 
#     return table_name, sanitized_columns
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 7. MODULE: rag_retriever.py
# %%writefile modules/rag_retriever.py
# import os
# from langchain_community.vectorstores import FAISS
# from langchain_community.embeddings import HuggingFaceEmbeddings
# from langchain.schema import Document
# import whisper
# 
# # üîÅ PATHS
# FAISS_PATH = "data/vector_store/faiss_index"
# 
# # ------------------ PART 1: General Knowledge Setup ------------------
# 
# def get_general_finance_knowledge():
#     """
#     Predefined general finance knowledge base.
#     """
#     texts = [
#         "The primary goal of financial management is to maximize shareholder wealth by making sound investment and financing decisions.",
#         "Financial statements include the balance sheet, income statement, and cash flow statement.",
#         "The balance sheet provides a snapshot of a company‚Äôs financial position at a specific point in time.",
#         "Cash flow statements show the inflows and outflows of cash, categorized into operating, investing, and financing activities.",
#         "Profitability ratios such as gross margin and net profit margin help assess a company‚Äôs financial performance.",
#         "Working capital management involves managing current assets and liabilities to ensure a company can meet its short-term obligations.",
#         "Capital budgeting is the process of evaluating and selecting long-term investments that are in line with the firm's goal of shareholder wealth maximization.",
#     ]
#     return [Document(page_content=text) for text in texts]
# 
# def setup_general_vector_store():
#     """
#     Embed and store general finance knowledge into FAISS.
#     """
#     documents = get_general_finance_knowledge()
#     return setup_vector_store(documents)
# 
# # ------------------ PART 2: Document Embedding & Search ------------------
# 
# def setup_vector_store(documents, save_index=True):
#     """
#     Embed documents and store them in FAISS vector DB.
#     """
#     embed = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
#     db = FAISS.from_documents(documents, embed)
#     if save_index:
#         save_vector_store(db)
#     return db
# 
# def save_vector_store(vector_store):
#     """
#     Save the FAISS vector store to local path.
#     """
#     vector_store.save_local(FAISS_PATH)
# 
# def load_vector_store():
#     """
#     Load FAISS vector store from local path.
#     """
#     index_path = os.path.join(FAISS_PATH, "index.faiss")
#     if os.path.exists(index_path):
#         embed = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
#         try:
#             return FAISS.load_local(FAISS_PATH, embed, allow_dangerous_deserialization=True)
#         except Exception as e:
#             print("‚ö†Ô∏è Failed to load FAISS index:", e)
#             return None
#     else:
#         return None
# 
# def query_vector_store(question, vector_store=None, k=1):
#     """
#     Perform semantic search with the input question.
#     """
#     if not vector_store:
#         vector_store = load_vector_store()
#         if not vector_store:
#             print("üß† No user-uploaded vector store found. Using general financial knowledge base...")
#             vector_store = setup_general_vector_store()
# 
#     result = vector_store.similarity_search(question, k=k)
#     return result[0].page_content if result else "‚ùå No relevant information found."
# 
# # ------------------ PART 3: Audio Input ‚Üí Semantic Answer ------------------
# 
# def transcribe_audio(audio_path):
#     """
#     Transcribe speech to text using OpenAI Whisper.
#     """
#     try:
#         model = whisper.load_model("base")  # Options: tiny, base, small, medium, large
#         result = model.transcribe(audio_path)
#         return result['text']
#     except Exception as e:
#         return f"‚ùå Failed to transcribe audio: {e}"
# 
# def query_from_audio(audio_path):
#     """
#     Convert audio ‚Üí question ‚Üí vector search ‚Üí answer.
#     """
#     question = transcribe_audio(audio_path)
#     if "‚ùå" in question:
#         return question
#     print(f"üé§ Transcribed Question: {question}")
#     return query_vector_store(question)
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 8. MODULE: logger.py
# %%writefile logs/logger.py
# import sqlite3
# from datetime import datetime
# import json
# 
# def log_to_db(intent, input_text, response, metadata=""):
#     conn = sqlite3.connect("logs/activity_log.db")
#     cursor = conn.cursor()
#     cursor.execute("""
#         INSERT INTO logs (timestamp, intent, input_text, response, metadata)
#         VALUES (?, ?, ?, ?, ?)""",
#         (str(datetime.now()), intent, input_text, json.dumps(response), metadata))
#     conn.commit()
#     conn.close()

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 9. MODULE: finance_apis/cash_management.py
# # ========================================
# %%writefile modules/finance_apis/cash_management.py
# import requests, os
# def get_summary():
#     api_key = os.getenv("ALPHA_VANTAGE_API_KEY")
#     url = f"https://www.alphavantage.co/query?function=CASH_FLOW&symbol=AAPL&apikey={api_key}"
#     response = requests.get(url)
#     data = response.json()
#     try:
#         report = data['annualReports'][0]
#         cash = report['cashAndCashEquivalentsAtCarryingValue']
#         return {"total_cash": f"${cash}", "available_cash": f"${cash}"}
#     except Exception as e:
#         return {"error": str(e)}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 10. MODULE: finance_apis/accounting.py
# # =====================================
# %%writefile modules/finance_apis/accounting.py
# import requests, os
# def get_balance():
#     api_key = os.getenv("ALPHA_VANTAGE_API_KEY")
#     url = f"https://www.alphavantage.co/query?function=BALANCE_SHEET&symbol=AAPL&apikey={api_key}"
#     response = requests.get(url)
#     data = response.json()
#     try:
#         report = data['annualReports'][0]
#         balance = report['cashAndCashEquivalentsAtCarryingValue']
#         return {"account_balance": f"${balance}"}
#     except Exception as e:
#         return {"error": str(e)}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ modules/finance_apis/tax_reporting.py
# %%writefile modules/finance_apis/tax_reporting.py
# import sqlite3, os
# from datetime import datetime
# from fpdf import FPDF
# import pandas as pd
# import re
# 
# def sanitize_column_name(name):
#     """Convert to SQLite-compatible snake_case column name."""
#     return re.sub(r'\W+', '_', str(name).strip().lower())
# 
# def parse_excel_to_db(file_path, db_path="data/financial_data.db"):
#     df = pd.read_excel(file_path)
#     original_columns = df.columns
#     sanitized_columns = [sanitize_column_name(col) for col in original_columns]
#     df.columns = sanitized_columns
# 
#     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
#     table_name = f"financial_data_{timestamp}"
# 
#     conn = sqlite3.connect(db_path)
#     cursor = conn.cursor()
# 
#     # Create dynamic SQL table
#     columns_sql = ", ".join([f"`{col}` TEXT" for col in sanitized_columns])
#     create_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}` (id INTEGER PRIMARY KEY AUTOINCREMENT, {columns_sql})"
#     cursor.execute(create_sql)
# 
#     df.to_sql(table_name, conn, if_exists='append', index=False)
#     conn.commit()
#     conn.close()
#     return table_name
# 
# def find_latest_excel(folder="data/uploaded_files"):
#     files = [f for f in os.listdir(folder) if f.endswith(".xlsx")]
#     if not files:
#         return None
#     files.sort(reverse=True)
#     return os.path.join(folder, files[0])
# 
# def generate_report():
#     db_path = "data/financial_data.db"
#     uploads_folder = "data/uploaded_files"  # Changed to the correct folder
#     pdf_folder = "pdf_reports"
# 
#     # Step 1: Get the latest Excel file
#     latest_excel = find_latest_excel(uploads_folder)
#     if not latest_excel:
#         return {"error": "No Excel files found in uploads folder."}
# 
#     # Step 2: Parse and save to DB
#     table_name = parse_excel_to_db(latest_excel, db_path)
# 
#     # Step 3: Fetch data
#     conn = sqlite3.connect(db_path)
#     cursor = conn.cursor()
#     cursor.execute(f"SELECT * FROM `{table_name}` LIMIT 5")
#     rows = cursor.fetchall()
#     columns = [description[0] for description in cursor.description]
#     conn.close()
# 
#     # Step 4: Generate PDF
#     if not os.path.exists(pdf_folder):
#         os.makedirs(pdf_folder)
#     filename = f"{pdf_folder}/tax_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.pdf"
# 
#     pdf = FPDF()
#     pdf.add_page()
#     pdf.set_font("Arial", size=12)
#     pdf.cell(200, 10, txt="Tax Report", ln=True, align="C")
# 
#     # Header
#     for col in columns:
#         pdf.cell(40, 10, txt=str(col), border=1)
#     pdf.ln()
# 
#     # Rows
#     for row in rows:
#         for val in row:
#             pdf.cell(40, 10, txt=str(val), border=1)
#         pdf.ln()
# 
#     pdf.output(filename)
# 
#     return {"status": "Report generated", "link": f"/{filename}", "table_name": table_name}
#

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 12. MODULE: api_handler.py
# # ===============================
# %%writefile modules/api_handler.py
# from modules.finance_apis import cash_management, accounting, tax_reporting
# def handle_api_call(intent):
#     if intent == "get_cashflow_summary":
#         return cash_management.get_summary()
#     elif intent == "generate_tax_report":
#         return tax_reporting.generate_report()
#     elif intent == "get_account_balance":
#         return accounting.get_balance()
#     else:
#         return {"error": "Unknown intent"}

# Commented out IPython magic to ensure Python compatibility.
# # ‚úÖ 13. MODULE: sql_loader.py
# # =================================
# %%writefile modules/sql_loader.py
# from langchain.schema import Document
# import sqlite3
# 
# def load_table_data(table_name: str):
#     conn = sqlite3.connect("data/financial_data.db")
#     cursor = conn.cursor()
# 
#     # Get column names
#     cursor.execute(f"PRAGMA table_info({table_name})")
#     columns_info = cursor.fetchall()
#     column_names = [col[1] for col in columns_info if col[1] != "id"]
# 
#     # Fetch all rows
#     cursor.execute(f"SELECT * FROM {table_name}")
#     rows = cursor.fetchall()
# 
#     documents = []
#     for row in rows:
#         row_dict = dict(zip(column_names, row[1:]))  # Skip the ID column
#         page_content = "\n".join([f"{k}: {v}" for k, v in row_dict.items()])
#         documents.append(Document(page_content=page_content, metadata={"source_table": table_name}))
# 
#     conn.close()
#     return documents
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile modules/__init__.py
# # This file marks the 'modules' folder as a Python package

# Commented out IPython magic to ensure Python compatibility.
# %%writefile modules/finance_apis/__init__.py
# # This file marks the 'finance_apis' folder as a sub-package

# Commented out IPython magic to ensure Python compatibility.
# %%writefile logs/__init__.py
# # This file marks the 'logs' folder as a Python package

#this code get only get_account_balance.mp3 & no files uploaded & fetch data
import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/get_account_balance.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

# this code i give generate tax report voice data and upload tax.excel file and it return pdf and a table name
import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/generate_tax_report.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#i give table name and asked question basis on the excel data that are saved in table and it answer well.
import os
import sqlite3
from modules.speech_to_text import transcribe_audio
from modules.rag_retriever import query_vector_store, load_vector_store, setup_vector_store
from logs.logger import log_to_db
from langchain.schema import Document

# üìç Config
audio_path = "/content/data/uploaded_files/q_frm_tax_data.mp3"
target_table = "financial_data_20250423_181713"
db_path = "data/financial_data.db"


def load_table_documents(table_name):
    """Loads data from the specified table and creates Langchain Documents."""
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute(f"SELECT * FROM `{table_name}`")
    rows = cursor.fetchall()
    column_names = [desc[0] for desc in cursor.description]
    conn.close()

    documents = []
    for row in rows:
        row_dict = dict(zip(column_names, row))
        if all(value in (None, "", " ") for value in row_dict.values()):
            continue
        row_text = f"Row Details:\n" + "\n".join([f"{k}: {v}" for k, v in row_dict.items()])
        doc = Document(page_content=row_text, metadata=row_dict)
        documents.append(doc)

    return documents


def format_full_row(metadata):
    return (
        "\n".join([f"{k}: {v}" for k, v in metadata.items()])
        if metadata
        else "‚ö†Ô∏è No matching row found."
    )


if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    vector_store = load_vector_store()

    if not vector_store:
        print("üì¶ Vector store not found. Generating and saving from table data...")
        documents = load_table_documents(target_table)
        vector_store = setup_vector_store(documents, save_index=True)

    matched_doc = query_vector_store(query, vector_store)

    if isinstance(matched_doc, str):
        final_answer = matched_doc
    else:
        matched_id = matched_doc.metadata.get("id")
        matched_question = matched_doc.metadata.get("Question")

        documents = load_table_documents(target_table)  # Ensure we have full table for filtering
        matching_rows = [doc.metadata for doc in documents if doc.metadata.get("Question") == matched_question]

        row_summary = {
            "id": matched_id,
            "Description": "",
            "Tax Rate (%)": ""
        }

        for row in matching_rows:
            desc = row.get("Description", "")
            if "employee salary" in desc.lower():
                row_summary["Description"] = desc
            if "tax rate" in desc.lower() or "%" in desc:
                row_summary["Tax Rate (%)"] = desc

        if not row_summary["Description"]:
            for row in matching_rows:
                if row.get("Description") and "expense" in row["Description"].lower():
                    row_summary["Description"] = row["Description"]
                    break

        final_answer = f"id: {row_summary['id']} | Description: {row_summary['Description']} | Tax Rate (%): {row_summary['Tax Rate (%)']}"

    response = {"rag_answer": final_answer}
    log_to_db(intent="dynamic_table_query", input_text=query, response=response)
    print("‚úÖ Final Response:", response)

else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#--------------------------   RAG  --------------------------------#
## ---------------------- RAG Random Question and give answer from dpredefined data -------------------------------- ##

from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.rag_retriever import load_vector_store, query_vector_store, setup_general_vector_store
from logs.logger import log_to_db
import os

# ‚úÖ STEP 1: Audio Input
audio_path = "/content/data/uploaded_files/random_question_1.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Use General Finance RAG system
    print("üì° Using General Finance RAG system...")

    vector_store = setup_general_vector_store()

    final_answer = query_vector_store(query, vector_store, k=3)  # Get plain string answer

    response = {"rag_answer": final_answer}
    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")



from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.rag_retriever import load_vector_store, query_vector_store, setup_general_vector_store
from logs.logger import log_to_db
import os

# ‚úÖ STEP 1: Audio Input
audio_path = "/content/data/uploaded_files/random_question.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Use General Finance RAG system
    print("üì° Using General Finance RAG system...")

    vector_store = setup_general_vector_store()

    final_answer = query_vector_store(query, vector_store, k=3)  # Get plain string answer

    response = {"rag_answer": final_answer}
    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

#------------------- cashflow ----------------------------
##this code get only get cashflow summary.mp3 & no files uploaded & fetch data
import os
import shutil
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from logs.logger import log_to_db
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from modules.file_parser import parse_and_store
from langchain.schema import Document
import sqlite3

#‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
from google.colab import files
uploaded = files.upload()
#‚úÖ Initialize saved_path before the loop to avoid NameError if no files are uploaded
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store table (If file was uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table = parse_and_store(saved_path)
    print(f"‚úÖ Parsed and saved to DB table: {target_table}")
else:
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Audio Input
audio_path = "/content/data/uploaded_files/get_cashflow_summary.mp3"
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    # ‚úÖ Handle known API-based financial intents
    if intent in ["get_cashflow_summary", "generate_tax_report", "get_account_balance"]:
        response = handle_api_call(intent)
        # If tax report and no file was uploaded, inform the user
        if intent == "generate_tax_report" and not saved_path:
            response = {"error": "No file uploaded for tax report generation."}

    # ‚úÖ Otherwise, use RAG system (FAISS) if a file was uploaded and parsed
    elif saved_path:
        print("üì° Using RAG system for intelligent retrieval...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT question, description FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()
            return [Document(page_content=desc, metadata={"question": q}) for q, desc in rows]

        # ‚úÖ Try loading saved vector index
        vector_store = load_vector_store()

        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index found. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index rebuilt and saved.")
        else:
            print("‚úÖ Loaded FAISS index successfully.")

        answer = query_vector_store(query, vector_store)
        response = {"rag_answer": answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for RAG."}

    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)
else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")

!mkdir /content/ai_finance_agent

!mv /content/audio_samples /content/ai_finance_agent/
!mv /content/data /content/ai_finance_agent/
!mv /content/logs /content/ai_finance_agent/
!mv /content/modules /content/ai_finance_agent/
!mv /content/pdf_reports /content/ai_finance_agent/

#!ls /content

# from google.colab import files
# files.download('/content/ai_finance_agent.zip')

#!cd /content && zip -r ai_finance_agent.zip ai_finance_agent

# If your ZIP is local
!unzip /content/AI_Finanace_Agent/ai_finance_agent.zip -d temp
!cp -r temp/ai_finance_agent/* AI_Finanace_Agent/

!git clone https://huggingface.co/spaces/nailahjahan/AI_Finanace_Agent
!cd AI_Finanace_Agent

!cp -r /content/ai_finance_agent/* /content/AI_Finanace_Agent/

!pip install gradio

!ls /content/AI_Finanace_Agent/modules/sql_loader.py

import gradio as gr
import sys
import os
from modules.speech_to_text import transcribe_audio # Updated import
from modules.intent_recognizer import get_intent # Updated import
from modules.finance_apis.cash_management import get_summary
from modules.finance_apis.accounting import get_balance
from modules.finance_apis.tax_reporting import generate_report
from modules.rag_retriever import ( # Updated import
    load_vector_store, setup_vector_store, query_vector_store
)
from logs.logger import log_to_db
# 1. Import the correct function
from modules.sql_loader import load_table_data

# 2. Alias it as needed
load_table_documents = load_table_data

UPLOAD_DIR = "data/uploaded_files"

def handle_voice(audio):
    # 1. Transcribe audio to text
    audio_path = audio if isinstance(audio, str) else audio.name
    query = transcribe_audio(audio_path) # Use correct function name

    # 2. Detect intent
    intent = get_intent(query) # Use correct function name

    # 3. Handle intents
    response = ""
    if intent == "get_cashflow_summary":
        response = get_summary()
    elif intent == "get_account_balance":
        response = get_balance()
    elif intent == "generate_tax_report":
        response = "Please upload an Excel file for tax summary."
    else:
        # General Q&A (RAG)
        vector_store = load_vector_store()
        if vector_store:
            response = query_vector_store(query, vector_store)
        else:
            response = "No knowledge base found. Please upload financial data first."

    # Log
    log_to_db(intent, query, str(response))

    return f"Intent: {intent}\nResponse: {response}"


def handle_excel(file):
    # Save the uploaded file
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    file_path = os.path.join(UPLOAD_DIR, file.name)
    file.save(file_path)

    # Generate report and get table name
    result = generate_report()
    if "error" in result:
        return result["error"]

    # Build FAISS index for RAG
    table_name = result["table_name"]
    docs = load_table_documents(table_name)  # Assuming load_table_documents exists in modules.rag_retriever
    setup_vector_store(docs, save_index=True)

    return f"‚úÖ Tax Report Generated.\nüîó PDF: {result['link']}\nüìä Table: {table_name}"


# Gradio UI
with gr.Blocks() as demo:
    gr.Markdown("## üéôÔ∏è AI Finance Assistant - Voice Command Based")

    with gr.Tab("üé§ Voice Command"):
        audio_input = gr.Audio(type="filepath", label="Speak your finance query")
        voice_btn = gr.Button("Process Voice Command")
        voice_output = gr.Textbox(label="Result")

    with gr.Tab("üìÇ Upload Tax Excel"):
        file_input = gr.File(file_types=[".xlsx"], label="Upload Excel for Tax Summary")
        file_btn = gr.Button("Generate Tax Report")
        file_output = gr.Textbox(label="Status")

    voice_btn.click(fn=handle_voice, inputs=[audio_input], outputs=[voice_output])
    file_btn.click(fn=handle_excel, inputs=[file_input], outputs=[file_output])

demo.launch()

# import gradio as gr
# from modules.speech_to_text import transcribe_audio
# from modules.intent_recognizer import get_intent
# from modules.api_handler import handle_api_call  # Changed import here
# from modules.finance_apis.tax_reporting import generate_report as generate_tax_report_from_uploaded_file # Assumed import (refer to your tax_reporting module)
# # Updated import to reflect correct location
# from modules.rag_retriever import query_vector_store as answer_custom_query  # Assumed import (refer to your rag_retriever module)
# # Updated import and the function name
# import os

# last_table_name = None  # Store last used table for RAG

# def run_agent(audio_file, uploaded_file=None):
#     global last_table_name
#     try:
#         # Step 1: Transcribe voice to text
#         transcribed_text = transcribe_audio(audio_file)
#         # Step 2: Identify intent from transcribed text
#         intent = get_intent(transcribed_text)
#         # Step 3: Route based on intent
#         if intent == "generate_tax_report":
#             if uploaded_file is None:
#                 return f"üó£Ô∏è You said: {transcribed_text}\nüìé Please upload a file to generate the tax report."
#             # Calling the generate_report function and getting file path and table name
#             result = generate_tax_report_from_uploaded_file()
#             pdf_path = result.get("link", "")
#             table_name = result.get("table_name", "")
#             last_table_name = table_name
#             return f"üó£Ô∏è You said: {transcribed_text}\n‚úÖ Tax report generated.\nüìÑ PDF: {pdf_path}\nüóÉÔ∏è Table: {table_name}"

#         elif intent in ["get_cashflow_summary", "get_account_balance"]:
#             # Call the appropriate API handler function
#             result = handle_api_call(intent)
#             return f"üó£Ô∏è You said: {transcribed_text}\nüìä {result}"

#         elif intent == "unknown_intent":
#             return f"üó£Ô∏è You said: {transcribed_text}\n‚ùì Sorry, I couldn't understand your intent."

#         else:
#             # Handle RAG-based question (from last processed table)
#             if last_table_name is None:
#                 return f"üó£Ô∏è You said: {transcribed_text}\n‚ö†Ô∏è No data table found. Please upload a financial file first."
#             # Call the query_vector_store function to answer custom queries
#             result = answer_custom_query(transcribed_text, vector_store=None, k=1)
#             return f"üó£Ô∏è You said: {transcribed_text}\nü§ñ {result}"

#     except Exception as e:
#         return f"‚ùå Error: {str(e)}"
# # Gradio UI
# inputs = [
#     gr.Audio(type="filepath", label="üéôÔ∏è Speak your command"),
#     gr.File(label="üìé Upload file (if needed for tax report)")
# ]
# interface = gr.Interface(
#     fn=run_agent,
#     inputs=inputs,
#     outputs=gr.Textbox(label="üìã Response"),
#     title="AI Finance Assistant",
#     description="Speak finance commands like 'generate tax report', 'get cashflow summary', or ask questions like 'What‚Äôs my net profit in 2023?'"
# )

# if __name__ == "__main__":
#     interface.launch(share=True, debug=True)



import os
import shutil
import sqlite3
import json
from datetime import datetime
from langchain.schema import Document
from google.colab import files

# ‚úÖ Import project modules
from modules.speech_to_text import transcribe_audio
from modules.intent_recognizer import get_intent
from modules.api_handler import handle_api_call
from modules.file_parser import parse_and_store
from modules.tax_report_generator import generate_tax_pdf
from modules.rag_retriever import (
    query_vector_store,
    setup_vector_store,
    load_vector_store,
    save_vector_store
)
from logs.logger import log_to_db

# ‚úÖ STEP 0: Upload and parse Excel/CSV file (Optional)
uploaded = files.upload()
saved_path = None
for fname in uploaded.keys():
    print(f"‚úÖ File uploaded: {fname}")
    saved_path = f"/content/data/uploaded_files/{fname}"
    shutil.move(fname, saved_path)

# ‚úÖ STEP 1: Parse and store file data in database (if uploaded)
if saved_path and saved_path.endswith((".xlsx", ".xls", ".csv")):
    target_table, columns = parse_and_store(saved_path)
    print(f"‚úÖ File parsed and stored in table: {target_table}")
else:
    target_table, columns = None, []
    print("‚ö†Ô∏è No file uploaded or unsupported format. Proceeding without file-based data.")

# ‚úÖ STEP 2: Transcribe audio to detect intent
audio_path = "/content/data/uploaded_files/voice_command.mp3"  # replace with correct name
if os.path.exists(audio_path):
    query = transcribe_audio(audio_path)
    print("üó£Ô∏è Transcribed Query:", query)

    intent = get_intent(query)
    print("üîç Detected Intent:", intent)

    response = {}

    # ‚úÖ STEP 3: Handle known financial intents
    if intent in ["get_cashflow_summary", "get_account_balance"]:
        response = handle_api_call(intent)

    elif intent == "generate_tax_report":
        if saved_path:
            output_pdf_path = generate_tax_pdf(saved_path)
            response = {
                "message": "‚úÖ Tax report generated.",
                "pdf_path": output_pdf_path,
                "table_name": target_table
            }
        else:
            response = {"error": "‚ö†Ô∏è No financial file uploaded for tax report."}

    # ‚úÖ STEP 4: Handle unknown intent using RAG
    elif saved_path:
        print("üì° Using RAG-based semantic search...")

        def load_table_data(table_name):
            conn = sqlite3.connect("data/financial_data.db")
            cursor = conn.cursor()
            cursor.execute(f"SELECT * FROM `{table_name}`")
            rows = cursor.fetchall()
            conn.close()

            docs = []
            for row in rows:
                content = "\n".join([f"{col}: {val}" for col, val in zip(columns, row[1:])])
                docs.append(Document(page_content=content))
            return docs

        # Load or build FAISS index
        vector_store = load_vector_store()
        if not vector_store:
            print("‚ö†Ô∏è No saved FAISS index. Rebuilding...")
            documents = load_table_data(target_table)
            vector_store = setup_vector_store(documents)
            save_vector_store(vector_store)
            print("‚úÖ FAISS index saved.")
        else:
            print("‚úÖ Loaded FAISS index.")

        rag_answer = query_vector_store(query, vector_store)
        response = {"rag_answer": rag_answer}
    else:
        response = {"error": "Unknown intent and no file uploaded for semantic retrieval."}

    # ‚úÖ STEP 5: Log and print final response
    log_to_db(intent, query, response)
    print("‚úÖ Final Response:", response)

else:
    print(f"‚ö†Ô∏è No audio file found at: {audio_path}")